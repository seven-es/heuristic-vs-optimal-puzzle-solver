# -*- coding: utf-8 -*-
"""PartC.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hz5nuHvfOBWbKtJcbN4yHr2zJ6ugXG7p
"""

import random
import time
import csv

def generate_individual(N):
    """
    Generates a random individual (permutation) representing a possible solution.
    Each index repr|esents a column, and the value at that index represents the row.
    """
    individual = list(range(N))
    random.shuffle(individual)
    return individual

def fitness(individual):
    """
    Calculates the number of conflicting pairs of queens.
    Lower fitness value means fewer conflicts.
    A fitness of 0 indicates a valid solution.
    """
    conflicts = 0
    N = len(individual)
    for i in range(N):
        for j in range(i + 1, N):
            if abs(individual[i] - individual[j]) == abs(i - j):
                conflicts += 1
    return conflicts

def tournament_selection(population, fitnesses, tournament_size):
    """
    Selects an individual from the population using tournament selection.
    Randomly selects 'tournament_size' individuals and returns the one with the best fitness.
    """
    selected_indices = random.sample(range(len(population)), tournament_size)
    selected = [(population[i], fitnesses[i]) for i in selected_indices]
    selected.sort(key=lambda x: x[1])  # Sort by fitness (lower is better)
    return selected[0][0]  # Return the best individual

def crossover(parent1, parent2):
    """
    Performs crossover on two parents to produce a child.
    Ensures that the child is a valid permutation (no duplicate values).
    """
    N = len(parent1)
    cxpoint1 = random.randint(0, N - 2)
    cxpoint2 = random.randint(cxpoint1 + 1, N - 1)
    child = [-1] * N  # Initialize with placeholder values

    # Copy the crossover segment
    child[cxpoint1:cxpoint2 + 1] = parent1[cxpoint1:cxpoint2 + 1]

    # Fill remaining positions with genes from parent2, avoiding duplicates
    p2_genes = [gene for gene in parent2 if gene not in child]
    index = 0
    for i in range(N):
        if child[i] == -1:
            child[i] = p2_genes[index]
            index += 1
    return child

def mutate(individual):
    """
    Performs swap mutation on an individual.
    Randomly selects two positions and swaps their values.
    """
    idx1, idx2 = random.sample(range(len(individual)), 2)
    individual[idx1], individual[idx2] = individual[idx2], individual[idx1]

def genetic_algorithm(N, max_generations=1000, population_size=100, mutation_rate=0.05):
    """
    Genetic Algorithm for solving the N-Queens problem.
    """
    population = [generate_individual(N) for _ in range(population_size)]
    fitnesses = [fitness(individual) for individual in population]

    for generation in range(max_generations):
        # Check if a solution is found
        if 0 in fitnesses:
            return population[fitnesses.index(0)]  # Return the solution

        # Generate new population
        new_population = []
        for _ in range(population_size // 2):
            # Selection
            parent1 = tournament_selection(population, fitnesses, tournament_size=5)
            parent2 = tournament_selection(population, fitnesses, tournament_size=5)
            # Crossover
            child = crossover(parent1, parent2)
            # Mutation
            if random.random() < mutation_rate:
                mutate(child)
            new_population.append(child)

        # Update population and fitnesses
        population = new_population
        fitnesses = [fitness(individual) for individual in population]

    return None  # Return None if no solution is found within max_generations

def main():
    start_N = 3
    end_N = 30
    num_runs = 10  # Number of runs for averaging

    results = []

    for N in range(start_N, end_N + 1):
        total_time = 0.0
        success_count = 0

        for _ in range(num_runs):
            start_time = time.perf_counter()
            solution = genetic_algorithm(N)
            end_time = time.perf_counter()
            time_taken = end_time - start_time
            total_time += time_taken

            if solution is not None:
                success_count += 1

        average_time = total_time / num_runs
        success_rate = (success_count / num_runs) * 100

        results.append({
            'N': N,
            'Average Time (seconds)': f"{average_time:.6f}",
            'Success Rate (%)': f"{success_rate:.2f}"
        })

        print(f"N = {N}: Average Time = {average_time:.6f}s, Success Rate = {success_rate:.2f}%")

        # Limit N based on success rate and time constraints
        if success_rate < 100 or average_time > 5.0:
            break

    # Write results to a CSV file
    with open('nqueen_genetic_algorithm_times.csv', 'w', newline='') as csvfile:
        fieldnames = ['N', 'Average Time (seconds)', 'Success Rate (%)']
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
        writer.writeheader()
        for result in results:
            writer.writerow(result)

    print("\nResults have been saved to 'nqueen_genetic_algorithm_times.csv'.")

if __name__ == '__main__':
    main()