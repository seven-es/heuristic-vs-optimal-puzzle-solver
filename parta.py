# -*- coding: utf-8 -*-
"""PartA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hz5nuHvfOBWbKtJcbN4yHr2zJ6ugXG7p
"""

# Python3 program to solve N Queen Problem
# and measure average time taken for N from start_N to end_N
import time
import csv
import sys

def printSolution(board, N):
    for i in range(N):
        for j in range(N):
            if board[i][j] == 1:
                print("Q", end=" ")
            else:
                print(".", end=" ")
        print()

def isSafe(board, row, col, N):
    # Check this row on left side
    for i in range(col):
        if board[row][i] == 1:
            return False

    # Check upper diagonal on left side
    for i, j in zip(range(row, -1, -1),
                    range(col, -1, -1)):
        if i < 0 or j < 0:
            break
        if board[i][j] == 1:
            return False

    # Check lower diagonal on left side
    for i, j in zip(range(row, N, 1),
                    range(col, -1, -1)):
        if i >= N or j < 0:
            break
        if board[i][j] == 1:
            return False

    return True

# Simple Backtracking
def solveNQSimple(board, col, N):
    if col >= N:
        return True

    for i in range(N):
        if isSafe(board, i, col, N):
            board[i][col] = 1
            if solveNQSimple(board, col + 1, N):
                return True
            board[i][col] = 0  # Backtrack
    return False

# Backtracking with Forward Checking
def solveNQForwardChecking(board, col, domains, N):
    if col >= N:
        return True

    for row in domains[col]:
        board[row][col] = 1

        # Make a deep copy of domains
        new_domains = [domain.copy() for domain in domains]
        forward_checking_success = True

        # Update domains for future columns
        for future_col in range(col + 1, N):
            attacked_rows = set()
            dist = future_col - col
            attacked_rows.add(row)
            diag1 = row + dist
            diag2 = row - dist
            if 0 <= diag1 < N:
                attacked_rows.add(diag1)
            if 0 <= diag2 < N:
                attacked_rows.add(diag2)

            new_domains[future_col] -= attacked_rows

            if not new_domains[future_col]:
                forward_checking_success = False
                break

        if forward_checking_success:
            if solveNQForwardChecking(board, col + 1, new_domains, N):
                return True

        board[row][col] = 0  # Backtrack

    return False

# Helper functions for MRV and LCV
def select_unassigned_variable_MRV(domains, unassigned_vars):
    min_domain_size = float('inf')
    min_var = None
    for var in unassigned_vars:
        domain_size = len(domains[var])
        if domain_size < min_domain_size:
            min_domain_size = domain_size
            min_var = var
    return min_var

def order_values_LCV(var, domains, unassigned_vars, N):
    value_constraints = {}
    for value in domains[var]:
        constraint = 0
        for future_var in unassigned_vars:
            if future_var == var:
                continue
            dist = abs(future_var - var)
            attacked_rows = set()
            attacked_rows.add(value)
            diag1 = value + dist
            diag2 = value - dist
            if 0 <= diag1 < N:
                attacked_rows.add(diag1)
            if 0 <= diag2 < N:
                attacked_rows.add(diag2)
            eliminated_values = domains[future_var] & attacked_rows
            constraint += len(eliminated_values)
        value_constraints[value] = constraint
    # Sort values by least constraining value
    return sorted(domains[var], key=lambda val: value_constraints[val])

# Backtracking with Forward Checking, MRV, and LCV
def solveNQMRVLCV(board, domains, unassigned_vars, N):
    if not unassigned_vars:
        return True

    # Select the variable (column) with MRV
    var = select_unassigned_variable_MRV(domains, unassigned_vars)

    # Order the values (rows) using LCV heuristic
    ordered_values = order_values_LCV(var, domains, unassigned_vars, N)

    for value in ordered_values:
        board[value][var] = 1

        # Make a deep copy of domains and unassigned_vars
        new_domains = [domain.copy() for domain in domains]
        new_unassigned_vars = unassigned_vars.copy()
        new_unassigned_vars.remove(var)
        forward_checking_success = True

        # Update domains for future variables
        for future_var in new_unassigned_vars:
            dist = abs(future_var - var)
            attacked_rows = set()
            attacked_rows.add(value)
            diag1 = value + dist
            diag2 = value - dist
            if 0 <= diag1 < N:
                attacked_rows.add(diag1)
            if 0 <= diag2 < N:
                attacked_rows.add(diag2)

            new_domains[future_var] -= attacked_rows

            if not new_domains[future_var]:
                forward_checking_success = False
                break

        if forward_checking_success:
            if solveNQMRVLCV(board, new_domains, new_unassigned_vars, N):
                return True

        board[value][var] = 0  # Backtrack

    return False

def main():
    # Parameters to set the range of N and number of runs
    start_N = 3
    end_N = 29  # Inclusive
    num_runs = 5  # Number of times each algorithm is run to compute average time

    # Limit for simple backtracking due to computational constraints
    simple_backtracking_max_N = 12

    # Initialize results list
    results = []

    print("Starting N-Queens computations...\n")

    for N in range(start_N, end_N + 1):
        print(f"Computing for N = {N}:")

        algorithms = {
            'Simple Backtracking': {
                'function': solveNQSimple,
                'enabled': N <= simple_backtracking_max_N,
                'times': [],
                'solution_exists': None
            },
            'Forward Checking': {
                'function': solveNQForwardChecking,
                'enabled': True,
                'times': [],
                'solution_exists': None
            },
            'Forward Checking with MRV and LCV': {
                'function': solveNQMRVLCV,
                'enabled': True,
                'times': [],
                'solution_exists': None
            }
        }

        for alg_name, alg_info in algorithms.items():
            if not alg_info['enabled']:
                print(f"  {alg_name}: Skipped due to computational constraints.")
                continue

            total_time = 0.0
            success_count = 0

            for run in range(num_runs):
                board = [[0] * N for _ in range(N)]
                start_time = time.perf_counter()

                if alg_name == 'Simple Backtracking':
                    solution_exists = alg_info['function'](board, 0, N)
                elif alg_name == 'Forward Checking':
                    domains = [set(range(N)) for _ in range(N)]
                    solution_exists = alg_info['function'](board, 0, domains, N)
                elif alg_name == 'Forward Checking with MRV and LCV':
                    domains = [set(range(N)) for _ in range(N)]
                    unassigned_vars = list(range(N))
                    solution_exists = alg_info['function'](board, domains, unassigned_vars, N)
                else:
                    solution_exists = False

                end_time = time.perf_counter()
                time_taken = end_time - start_time
                alg_info['times'].append(time_taken)
                total_time += time_taken

                if solution_exists:
                    success_count += 1

            average_time = total_time / num_runs
            alg_info['average_time'] = average_time
            alg_info['solution_exists'] = success_count > 0

            if alg_info['solution_exists']:
                print(f"  {alg_name}: Average time over {num_runs} runs: {average_time:.6f} seconds")
                # Uncomment the following line to print the solution board
                # printSolution(board, N)
            else:
                print(f"  {alg_name}: No solution exists. Average computation time over {num_runs} runs: {average_time:.6f} seconds")

            # Append results
            results.append({
                'N': N,
                'Algorithm': alg_name,
                'Average Time (seconds)': f"{average_time:.6f}",
                'Solution Exists': alg_info['solution_exists']
            })

    # Write results to CSV file
    with open('nqueen_times_average.csv', 'w', newline='') as csvfile:
        fieldnames = ['N', 'Algorithm', 'Average Time (seconds)', 'Solution Exists']
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)

        writer.writeheader()
        for result in results:
            writer.writerow(result)

    print("\nAverage timing results have been saved to 'nqueen_times_average.csv'.")

if __name__ == '__main__':
    main()