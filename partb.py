# -*- coding: utf-8 -*-
"""PartB.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hz5nuHvfOBWbKtJcbN4yHr2zJ6ugXG7p
"""

import random
import math
import time
import csv

def generate_initial_state(N):
    state = list(range(N))
    random.shuffle(state)
    return state

def heuristic(state, N):
    conflicts = 0
    for i in range(N):
        for j in range(i + 1, N):
            if abs(state[i] - state[j]) == abs(i - j):
                conflicts += 1
    return conflicts

def get_random_neighbor(state, N):
    neighbor = state.copy()
    col = random.randint(0, N - 1)
    row_choices = list(set(range(N)) - {state[col]})
    neighbor[col] = random.choice(row_choices)
    return neighbor

def simulated_annealing(N, max_iterations=100000):
    current_state = generate_initial_state(N)
    current_cost = heuristic(current_state, N)
    T = N * N  # Initial temperature
    alpha = 0.99  # Cooling rate
    min_T = 0.1  # Minimum temperature

    iterations = 0
    while current_cost > 0 and iterations < max_iterations:
        T = max(T * alpha, min_T)
        new_state = get_random_neighbor(current_state, N)
        new_cost = heuristic(new_state, N)
        delta_E = new_cost - current_cost

        if delta_E < 0 or random.uniform(0, 1) < math.exp(-delta_E / T):
            current_state = new_state
            current_cost = new_cost

        iterations += 1

    return current_state if current_cost == 0 else None

def main():
    start_N = 4
    end_N = 30  # Adjust as needed
    num_runs = 10  # Number of runs for averaging

    results = []

    for N in range(start_N, end_N + 1):
        total_time = 0.0
        success_count = 0

        for _ in range(num_runs):
            start_time = time.perf_counter()
            solution = simulated_annealing(N)
            end_time = time.perf_counter()
            time_taken = end_time - start_time
            total_time += time_taken

            if solution is not None:
                success_count += 1

        average_time = total_time / num_runs
        success_rate = (success_count / num_runs) * 100

        results.append({
            'N': N,
            'Average Time (seconds)': f"{average_time:.6f}",
            'Success Rate (%)': f"{success_rate:.2f}"
        })

        print(f"N = {N}: Average Time = {average_time:.6f}s, Success Rate = {success_rate:.2f}%")

        # Limit N based on success rate and time constraints
        if success_rate < 100 or average_time > 5.0:
            break

    # Write results to CSV file
    with open('nqueen_simulated_annealing_times.csv', 'w', newline='') as csvfile:
        fieldnames = ['N', 'Average Time (seconds)', 'Success Rate (%)']
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)

        writer.writeheader()
        for result in results:
            writer.writerow(result)

    print("\nResults have been saved to 'nqueen_simulated_annealing_times.csv'.")

if __name__ == '__main__':
    main()