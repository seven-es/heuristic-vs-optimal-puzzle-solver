# -*- coding: utf-8 -*-
"""Notebook.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dqpawss6NUDP4BIjL44hcqDfHzcq1W5W
"""

# @title Default title text
# import sys
# import time
# import random
# from collections import deque

# class Board:
#     def __init__(self, size, board=None):
#         self.size = size
#         if board:
#             # Ensure board is deep copied
#             self.board = [row[:] for row in board]
#         else:
#             # Create a shuffled board of size*size
#             tiles = list(range(1, self.size * self.size)) + [0]
#             random.shuffle(tiles)
#             self.board = [tiles[i * self.size:(i + 1) * self.size] for i in range(self.size)]
#         # Find the empty tile
#         self.empty = next((r, c) for r in range(self.size) for c in range(self.size) if self.board[r][c] == 0)

#     def create_random(self):
#         tiles = list(range(1, self.size * self.size)) + [0]
#         random.shuffle(tiles)
#         self.board = [tiles[i * self.size:(i + 1) * self.size] for i in range(self.size)]
#         self.empty = next((r, c) for r in range(self.size) for c in range(self.size) if self.board[r][c] == 0)

#     def is_solvable(self):
#         # Placeholder for actual solvability check
#         return True

#     def __str__(self):
#         return '\n'.join(' '.join(map(str, row)) for row in self.board)

#     def is_goal_state(self):
#         # Create a goal state and compare to current board state
#         goal_state = [list(range(1 + i * self.size, 1 + (i + 1) * self.size)) for i in range(self.size)]
#         goal_state[-1][-1] = 0  # Set the last element to 0
#         return self.board == goal_state

#     def move(self, action):
#         r, c = self.empty
#         dr, dc = {'Up': (-1, 0), 'Down': (1, 0), 'Left': (0, -1), 'Right': (0, 1)}.get(action, (0, 0))
#         nr, nc = r + dr, c + dc
#         if 0 <= nr < self.size and 0 <= nc < self.size:
#             new_board = [row[:] for row in self.board]  # Copy the board
#             new_board[r][c], new_board[nr][nc] = new_board[nr][nc], new_board[r][c]  # Swap tiles
#             new_empty = (nr, nc)
#             return Board(self.size, new_board), new_empty
#         return None

# def bfs_solve(board):
#     queue = deque([(board, [])])
#     seen = set()
#     seen.add(tuple(tuple(row) for row in board.board))
#     while queue:
#         current_board, path = queue.popleft()
#         if current_board.is_goal_state():
#             return path, len(path), len(queue)
#         for action in ["Up", "Down", "Left", "Right"]:
#             result = current_board.move(action)
#             if result:
#                 new_board, new_empty = result
#                 if tuple(tuple(row) for row in new_board.board) not in seen:
#                     seen.add(tuple(tuple(row) for row in new_board.board))
#                     queue.append((new_board, path + [action]))
#     return None, 0, 0

# def main(N):
#     print(f"Number of rows/columns: {N}")
#     trial = 10
#     print(f"Number of Trials: {trial}")
#     for loop in range(trial):
#         print(f"Trial {loop + 1}")
#         init_board = Board(N)
#         init_board.create_random()
#         while not init_board.is_solvable():
#             init_board.create_random()
#         print("Initial board:")
#         print(init_board)
#         solution = bfs_solve(init_board)
#         if solution:
#             print("Solution found:", solution)
#         else:
#             print("No solution found.")
#         gc.collect()  # Manual garbage collection

# if __name__ == "__main__":
#     try:
#         N = int(sys.argv[1]) if len(sys.argv) > 1 else 3
#     except ValueError:
#         print("Invalid input for board size, using default size N = 3")
#         N = 3
#     main(N)




# import psutil
# import os
# import gc
# import sys
# import random
# from collections import deque
# import numpy as np

# class Board:
#     def __init__(self, size, board=None):
#         self.size = size
#         if board:
#             self.board = board
#         else:
#             tiles = list(range(self.size * self.size))
#             random.shuffle(tiles)
#             self.board = [tiles[i * self.size:(i + 1) * self.size] for i in range(self.size)]
#         self.empty = next((r, c) for r in range(self.size) for c in range(self.size) if self.board[r][c] == 0)


#     def is_goal_state(self):
#         goal_state = [list(range(1 + i * self.size, 1 + (i + 1) * self.size)) for i in range(self.size)]
#         goal_state[-1][-1] = 0  # set the last element to 0 for the blank space
#         return self.board == goal_state


#     def move(self, action):
#         r, c = self.empty
#         dr, dc = {'Up': (-1, 0), 'Down': (1, 0), 'Left': (0, -1), 'Right': (0, 1)}.get(action, (0, 0))
#         nr, nc = r + dr, c + dc
#         if 0 <= nr < self.size and 0 <= nc < self.size:
#             new_board = [row[:] for row in self.board]
#             new_board[r][c], new_board[nr][nc] = new_board[nr][nc], new_board[r][c]
#             new_empty = (nr, nc)
#             return Board(self.size, new_board), new_empty
#         return None

#     def is_solvable(self):
#         flat_board = [tile for row in self.board for tile in row if tile != 0]
#         inversions = 0
#         for i in range(len(flat_board)):
#             for j in range(i + 1, len(flat_board)):
#                 if flat_board[i] > flat_board[j]:
#                     inversions += 1
#         return inversions % 2 == 0

#     def __str__(self):
#         return '\n'.join(' '.join(map(str, row)) for row in self.board)

# def bfs_solve(board):
#     queue = deque([(board, [])])
#     seen = set()
#     seen.add(tuple(tuple(row) for row in board.board))
#     while queue:
#         current_board, path = queue.popleft()
#         if current_board.is_goal_state():
#             return ', '.join(path), len(path), len(queue)  # Format the path as a string of moves
#         for action in ["Up", "Down", "Left", "Right"]:
#             result = current_board.move(action) # Modify this line
#             if result:
#                 new_board, new_empty = result
#                 if new_board and tuple(tuple(row) for row in new_board.board) not in seen:
#                     seen.add(tuple(tuple(row) for row in new_board.board))
#                     queue.append((new_board, path + [action]))  # Append the action to path
#     return None


# def simulate_board_solutions(size, trials=10):
#     depths = []
#     max_states_stored = []

#     for _ in range(trials):
#         board = Board(size)
#         while not board.is_solvable():
#             board = Board(size)  # Re-initialize if not solvable

#         print("Initial board:")
#         print(board)

#         result = bfs_solve(board)
#         if result:
#             solution, final_depth, max_states = result
#             depths.append(final_depth)
#             max_states_stored.append(max_states)

#             print("Solution found with steps:")
#             print(solution)  # Correctly print the solution steps
#             print("Final board configuration after solution:")
#             final_board = board
#             for move in solution.split(', '):  # Apply each move to get the final configuration
#                 final_board, _ = final_board.move(move)
#             print(final_board)
#             gc.collect()
#       ##  Result in out of memory
#         # else:
#         #     print("No solution found.")
#         #     gc.collect()
#         # dfs_result = dfs_solve(board)
#         # if dfs_result:
#         #     dfs_solution, dfs_length = dfs_result
#         #     gc.collect()
#         #     print("DFS Solution found with steps:", dfs_solution)
#         #     print("DFS Solution length:", dfs_length)
#         #     gc.collect()
#         else:
#             print("No DFS solution found.")
#     print("Depth Stats: Min:", np.min(depths), "Max:", np.max(depths), "Average:", np.mean(depths))
#     print("Max States Stored Stats: Min:", np.min(max_states_stored), "Max:", np.max(max_states_stored), "Average:", np.mean(max_states_stored))

# def dfs_solve(board):
#     stack = [(board, [])]
#     seen = set()
#     seen.add(tuple(tuple(row) for row in board.board))
#     while stack:
#         current_board, path = stack.pop()
#         if current_board.is_goal_state():
#             return ', '.join(path), len(path), len(stack)  # Format the path as a string of moves
#         for action in ["Up", "Down", "Left", "Right"]:
#             result = current_board.move(action) # Modify this line
#             if result:
#                 new_board, new_empty = result
#                 if new_board and tuple(tuple(row) for row in new_board.board) not in seen:
#                     seen.add(tuple(tuple(row) for row in new_board.board))
#                     stack.append((new_board, path + [action]))  # Append the action to path
#     return None
# def print_statistics(depths, max_states_stored):
#     print("Depth Stats: Min:", np.min(depths), "Max:", np.max(depths), "Average:", np.mean(depths))
#     print("Max States Stored Stats: Min:", np.min(max_states_stored), "Max:", np.max(max_states_stored), "Average:", np.mean(max_states_stored))

# def main():
#     for N in range(3, 7):
#         print(f"Running simulations for board size {N}x{N}")
#         simulate_board_solutions(N)

# if __name__ == "__main__":
#     main()


import gc
import sys
import random
from collections import deque
import numpy as np
import psutil
import os

class Board:
    def __init__(self, size, board=None):
        self.size = size
        if board:
            self.board = board
        else:
            tiles = list(range(self.size * self.size))
            random.shuffle(tiles)
            self.board = [tiles[i * self.size:(i + 1) * self.size] for i in range(self.size)]
        self.empty = next((r, c) for r in range(self.size) for c in range(self.size) if self.board[r][c] == 0)

    def is_goal_state(self):
        goal_state = [list(range(1 + i * self.size, 1 + (i + 1) * self.size)) for i in range(self.size)]
        goal_state[-1][-1] = 0  # Set the last element to 0 for the blank space
        return self.board == goal_state

    def move(self, action):
        r, c = self.empty
        dr, dc = {'Up': (-1, 0), 'Down': (1, 0), 'Left': (0, -1), 'Right': (0, 1)}.get(action, (0, 0))
        nr, nc = r + dr, c + dc
        if 0 <= nr < self.size and 0 <= nc < self.size:
            new_board = [row[:] for row in self.board]
            new_board[r][c], new_board[nr][nc] = new_board[nr][nc], new_board[r][c]
            new_empty = (nr, nc)
            new_board_obj = Board(self.size, new_board)
            new_board_obj.empty = new_empty  # Update the empty position
            return new_board_obj, new_empty
        return None

    def is_solvable(self):
        flat_board = [tile for row in self.board for tile in row if tile != 0]
        inversions = 0
        for i in range(len(flat_board)):
            for j in range(i + 1, len(flat_board)):
                if flat_board[i] > flat_board[j]:
                    inversions += 1
        if self.size % 2 == 1:
            return inversions % 2 == 0
        else:
            empty_row = self.empty[0]
            if empty_row % 2 == 0:
                return inversions % 2 == 1
            else:
                return inversions % 2 == 0

    def __str__(self):
        return '\n'.join(' '.join(f"{num:2d}" for num in row) for row in self.board)

def bfs_solve(board):
    queue = deque([(board, [])])
    seen = set()
    seen.add(tuple(tuple(row) for row in board.board))
    max_queue_size = 1  # Keep track of the maximum queue size
    while queue:
        current_board, path = queue.popleft()
        if current_board.is_goal_state():
            solution_steps = ', '.join(path)
            return solution_steps, len(path), max_queue_size  # Return solution steps, depth, and max queue size
        for action in ["Up", "Down", "Left", "Right"]:
            result = current_board.move(action)
            if result:
                new_board, new_empty = result
                board_state = tuple(tuple(row) for row in new_board.board)
                if new_board and board_state not in seen:
                    seen.add(board_state)
                    queue.append((new_board, path + [action]))  # Append the action to path
                    max_queue_size = max(max_queue_size, len(queue))
    return None

def dfs_solve(board):
    stack = [(board, [])]
    seen = set()
    seen.add(tuple(tuple(row) for row in board.board))
    iteration = 0  # Initialize an iteration counter

    # Get the total memory available
    total_memory = psutil.virtual_memory().total
    process = psutil.Process(os.getpid())

    max_stack_size = 1  # Keep track of the maximum stack size

    while stack:
        iteration += 1

        # Check memory usage every 1000 iterations
        if iteration % 1000 == 0:
            current_memory = process.memory_info().rss
            if current_memory / total_memory > 0.8:
                print("Memory usage exceeded 80%. Stopping DFS.")
                return None

        current_board, path = stack.pop()
        if current_board.is_goal_state():
            solution_steps = ', '.join(path)
            return solution_steps, len(path), max_stack_size  # Return solution steps, depth, and max stack size

        for action in ["Up", "Down", "Left", "Right"]:
            result = current_board.move(action)
            if result:
                new_board, new_empty = result
                board_state = tuple(tuple(row) for row in new_board.board)
                if new_board and board_state not in seen:
                    seen.add(board_state)
                    stack.append((new_board, path + [action]))  # Append the action to path
                    max_stack_size = max(max_stack_size, len(stack))
    return None

def simulate_board_solutions(size, trials=10):
    bfs_depths = []
    bfs_max_states_stored = []
    dfs_depths = []
    dfs_max_states_stored = []

    for _ in range(trials):
        board = Board(size)
        while not board.is_solvable():
            board = Board(size)  # Re-initialize if not solvable

        print("Initial board:")
        print(board)

        # BFS Solve
        result = bfs_solve(board)
        if result:
            solution_steps, final_depth, max_states = result
            bfs_depths.append(final_depth)
            bfs_max_states_stored.append(max_states)

            print("BFS Solution found.")
            print("Solution steps:", solution_steps)
            print("Solution length:", final_depth)
            print("Maximum states stored in BFS:", max_states)
            gc.collect()
        else:
            print("No BFS solution found.")
            gc.collect()

        # DFS Solve
        dfs_result = dfs_solve(board)
        if dfs_result:
            dfs_solution_steps, dfs_length, dfs_max_states = dfs_result
            dfs_depths.append(dfs_length)
            dfs_max_states_stored.append(dfs_max_states)
            print("DFS Solution found.")
            print("Solution steps:", dfs_solution_steps)
            print("Solution length:", dfs_length)
            print("Maximum states stored in DFS:", dfs_max_states)
        else:
            print("No DFS solution found or DFS stopped due to memory constraints.")
        gc.collect()
    print("Solution Depth: Min:", np.min(bfs_depths), "Max:", np.max(bfs_depths), "Average:", np.mean(bfs_depths))

    # After all trials, print statistical analysis
    print(f"\nBFS Statistical Analysis for board size {size}x{size}:")
    if bfs_depths:
      print("Max States Stored: Min:", np.min(bfs_max_states_stored), "Max:", np.max(bfs_max_states_stored), "Average:", np.mean(bfs_max_states_stored))
    else:
        print("No BFS solutions found.")

    print(f"\nDFS Statistical Analysis for board size {size}x{size}:")
    if dfs_depths:
        print("Solution Depth: Min:", np.min(dfs_depths), "Max:", np.max(dfs_depths), "Average:", np.mean(dfs_depths))
        print("Max States Stored: Min:", np.min(dfs_max_states_stored), "Max:", np.max(dfs_max_states_stored), "Average:", np.mean(dfs_max_states_stored))
    else:
        print("No DFS solutions found or all DFS searches stopped due to memory constraints.")

def main():
    for N in range(3, 7):
        print(f"\nRunning simulations for board size {N}x{N}")
        simulate_board_solutions(N, trials=10)

if __name__ == "__main__":
    main()

import gc
import random
from collections import deque
import numpy as np
import psutil
import os

class Board:
    def __init__(self, size, board=None):
        self.size = size
        if board:
            self.board = board
        else:
            tiles = list(range(self.size * self.size))
            random.shuffle(tiles)
            self.board = [tiles[i * self.size:(i + 1) * self.size] for i in range(self.size)]
        self.empty = next((r, c) for r in range(self.size) for c in range(self.size) if self.board[r][c] == 0)

    def is_goal_state(self):
        goal_state = [list(range(1 + i * self.size, 1 + (i + 1) * self.size)) for i in range(self.size)]
        goal_state[-1][-1] = 0  # Set the last element to 0 for the blank space
        return self.board == goal_state

    def move(self, action):
        r, c = self.empty
        dr, dc = {'Up': (-1, 0), 'Down': (1, 0), 'Left': (0, -1), 'Right': (0, 1)}.get(action, (0, 0))
        nr, nc = r + dr, c + dc
        if 0 <= nr < self.size and 0 <= nc < self.size:
            new_board = [row[:] for row in self.board]
            new_board[r][c], new_board[nr][nc] = new_board[nr][nc], new_board[r][c]
            new_empty = (nr, nc)
            new_board_obj = Board(self.size, new_board)
            new_board_obj.empty = new_empty  # Update the empty position
            return new_board_obj, new_empty
        return None

    def is_solvable(self):
        flat_board = [tile for row in self.board for tile in row if tile != 0]
        inversions = 0
        for i in range(len(flat_board)):
            for j in range(i + 1, len(flat_board)):
                if flat_board[i] > flat_board[j]:
                    inversions += 1
        if self.size % 2 == 1:
            return inversions % 2 == 0
        else:
            empty_row = self.empty[0]
            if empty_row % 2 == 0:
                return inversions % 2 == 1
            else:
                return inversions % 2 == 0

    def __str__(self):
        return '\n'.join(' '.join(f"{num:2d}" for num in row) for row in self.board)

# Convert board state to a tuple of tuples for use in `seen`
def board_to_tuple(board):
    return tuple(tuple(row) for row in board.board)

# Breadth-First Search (BFS) Implementation
def bfs_solve(board):
    queue = deque([(board, [])])
    seen = set()
    seen.add(board_to_tuple(board))
    max_queue_size = 1  # Track the maximum queue size
    while queue:
        current_board, path = queue.popleft()
        if current_board.is_goal_state():
            solution_steps = ', '.join(path)
            return solution_steps, len(path), max_queue_size  # Return solution steps, depth, and max queue size
        for action in ["Up", "Down", "Left", "Right"]:
            result = current_board.move(action)
            if result:
                new_board, new_empty = result
                board_state = board_to_tuple(new_board)
                if board_state not in seen:
                    seen.add(board_state)
                    queue.append((new_board, path + [action]))  # Append the action to path
                    max_queue_size = max(max_queue_size, len(queue))
    return None

# Depth-First Search (DFS) Implementation
def dfs_solve(board):
    stack = [(board, [])]
    seen = set()
    seen.add(board_to_tuple(board))
    max_stack_size = 1  # Track the maximum stack size
    while stack:
        current_board, path = stack.pop()
        if current_board.is_goal_state():
            solution_steps = ', '.join(path)
            return solution_steps, len(path), max_stack_size  # Return solution steps, depth, and max stack size
        for action in ["Up", "Down", "Left", "Right"]:
            result = current_board.move(action)
            if result:
                new_board, new_empty = result
                board_state = board_to_tuple(new_board)
                if board_state not in seen:
                    seen.add(board_state)
                    stack.append((new_board, path + [action]))  # Append the action to path
                    max_stack_size = max(max_stack_size, len(stack))
    return None

# Simulation and statistical analysis function
def simulate_board_solutions(size, trials=10):
    bfs_depths = []
    bfs_max_states_stored = []
    dfs_depths = []
    dfs_max_states_stored = []

    for _ in range(trials):
        board = Board(size)
        while not board.is_solvable():
            board = Board(size)  # Re-initialize if not solvable

        print("Initial board:")
        print(board)

        # BFS Solve
        result = bfs_solve(board)
        if result:
            solution_steps, final_depth, max_states = result
            bfs_depths.append(final_depth)
            bfs_max_states_stored.append(max_states)

            print("BFS Solution found.")
            print("Solution steps:", solution_steps)
            print("Solution length:", final_depth)
            print("Maximum states stored in BFS:", max_states)
            gc.collect()
        else:
            print("No BFS solution found.")
            gc.collect()

        # DFS Solve
        dfs_result = dfs_solve(board)
        if dfs_result:
            dfs_solution_steps, dfs_length, dfs_max_states = dfs_result
            dfs_depths.append(dfs_length)
            dfs_max_states_stored.append(dfs_max_states)
            print("DFS Solution found.")
            print("Solution steps:", dfs_solution_steps)
            print("Solution length:", dfs_length)
            print("Maximum states stored in DFS:", dfs_max_states)
        else:
            print("No DFS solution found or DFS stopped due to memory constraints.")
        gc.collect()

    # After all trials, print statistical analysis
    print(f"\nBFS Statistical Analysis for board size {size}x{size}:")
    if bfs_depths:
        print("Solution Depth: Min:", np.min(bfs_depths), "Max:", np.max(bfs_depths), "Average:", np.mean(bfs_depths))
        print("Max States Stored: Min:", np.min(bfs_max_states_stored), "Max:", np.max(bfs_max_states_stored), "Average:", np.mean(bfs_max_states_stored))
    else:
        print("No BFS solutions found.")

    print(f"\nDFS Statistical Analysis for board size {size}x{size}:")
    if dfs_depths:
        print("Solution Depth: Min:", np.min(dfs_depths), "Max:", np.max(dfs_depths), "Average:", np.mean(dfs_depths))
        print("Max States Stored: Min:", np.min(dfs_max_states_stored), "Max:", np.max(dfs_max_states_stored), "Average:", np.mean(dfs_max_states_stored))
    else:
        print("No DFS solutions found or all DFS searches stopped due to memory constraints.")

# Main function to run the simulation
def main():
    for N in range(3, 7):
        print(f"\nRunning simulations for board size {N}x{N}")
        simulate_board_solutions(N, trials=10)

if __name__ == "__main__":
    main()

import gc
import sys
import random
from collections import deque
import numpy as np
import psutil
import os
import heapq
import itertools

class Board:
    def __init__(self, size, board=None):
        self.size = size
        if board:
            self.board = board
        else:
            tiles = list(range(self.size * self.size))
            random.shuffle(tiles)
            self.board = [tiles[i * self.size:(i + 1) * self.size] for i in range(self.size)]
        self.empty = next((r, c) for r in range(self.size) for c in range(self.size) if self.board[r][c] == 0)

        # Precompute goal positions for each tile
        self.goal_positions = {tile: ((tile - 1) // self.size, (tile - 1) % self.size) for tile in range(1, self.size * self.size)}
        self.goal_positions[0] = (self.size - 1, self.size - 1)  # Empty tile position

    def is_goal_state(self):
        goal_state = [list(range(1 + i * self.size, 1 + (i + 1) * self.size)) for i in range(self.size)]
        goal_state[-1][-1] = 0  # Set the last element to 0 for the blank space
        return self.board == goal_state

    def move(self, action):
        r, c = self.empty
        dr, dc = {'Up': (-1, 0), 'Down': (1, 0), 'Left': (0, -1), 'Right': (0, 1)}.get(action, (0, 0))
        nr, nc = r + dr, c + dc
        if 0 <= nr < self.size and 0 <= nc < self.size:
            new_board = [row[:] for row in self.board]
            new_board[r][c], new_board[nr][nc] = new_board[nr][nc], new_board[r][c]
            new_empty = (nr, nc)
            new_board_obj = Board(self.size, new_board)
            new_board_obj.empty = new_empty  # Update the empty position
            return new_board_obj, new_empty
        return None

    def is_solvable(self):
        flat_board = [tile for row in self.board for tile in row if tile != 0]
        inversions = 0
        for i in range(len(flat_board)):
            for j in range(i + 1, len(flat_board)):
                if flat_board[i] > flat_board[j]:
                    inversions += 1
        if self.size % 2 == 1:
            return inversions % 2 == 0
        else:
            empty_row = self.empty[0]
            if empty_row % 2 == 0:
                return inversions % 2 == 1
            else:
                return inversions % 2 == 0

    def __str__(self):
        return '\n'.join(' '.join(f"{num:2d}" for num in row) for row in self.board)

def misplaced_tiles(board):
    count = 0
    for r in range(board.size):
        for c in range(board.size):
            tile = board.board[r][c]
            if tile != 0 and (r, c) != board.goal_positions[tile]:
                count += 1
    return count

def manhattan_distance(board):
    distance = 0
    for r in range(board.size):
        for c in range(board.size):
            tile = board.board[r][c]
            if tile != 0:
                goal_r, goal_c = board.goal_positions[tile]
                distance += abs(r - goal_r) + abs(c - goal_c)
    return distance

def euclidean_distance(board):
    distance = 0.0
    for r in range(board.size):
        for c in range(board.size):
            tile = board.board[r][c]
            if tile != 0:
                goal_r, goal_c = board.goal_positions[tile]
                distance += ((r - goal_r) ** 2 + (c - goal_c) ** 2) ** 0.5
    return distance

# Commented out BFS approach
'''
def bfs_solve(board):
    # BFS implementation
    pass
'''

# Commented out DFS approach
'''
def dfs_solve(board):
    # DFS implementation
    pass
'''

def astar_solve(board, heuristic_func):
    counter = itertools.count()
    open_set = []
    heapq.heappush(open_set, (heuristic_func(board), 0, next(counter), board, []))  # (f_score, g_score, count, board, path)
    seen = set()
    seen.add(tuple(tuple(row) for row in board.board))
    max_queue_size = 1
    while open_set:
        f_score, g_score, _, current_board, path = heapq.heappop(open_set)
        if current_board.is_goal_state():
            solution_steps = ', '.join(path)
            return solution_steps, len(path), max_queue_size  # Return solution steps, depth, and max queue size
        for action in ["Up", "Down", "Left", "Right"]:
            result = current_board.move(action)
            if result:
                new_board, new_empty = result
                board_state = tuple(tuple(row) for row in new_board.board)
                if board_state not in seen:
                    seen.add(board_state)
                    new_g_score = g_score + 1  # cost from start to neighbor
                    h_score = heuristic_func(new_board)
                    new_f_score = new_g_score + h_score
                    heapq.heappush(open_set, (new_f_score, new_g_score, next(counter), new_board, path + [action]))
                    max_queue_size = max(max_queue_size, len(open_set))
    return None

def simulate_board_solutions(size, trials=10):
    # BFS and DFS statistics are commented out
    '''
    bfs_depths = []
    bfs_max_states_stored = []
    dfs_depths = []
    dfs_max_states_stored = []
    '''

    astar_misplaced_depths = []
    astar_misplaced_max_states_stored = []
    astar_manhattan_depths = []
    astar_manhattan_max_states_stored = []
    astar_euclidean_depths = []
    astar_euclidean_max_states_stored = []

    for _ in range(trials):
        board = Board(size)
        while not board.is_solvable():
            board = Board(size)  # Re-initialize if not solvable

        print("Initial board:")
        print(board)

        # Commented out BFS solve
        '''
        # BFS Solve
        result = bfs_solve(board)
        if result:
            # Handle BFS result
            pass
        '''

        # Commented out DFS solve
        '''
        # DFS Solve
        dfs_result = dfs_solve(board)
        if dfs_result:
            # Handle DFS result
            pass
        '''

        # A* Solve with Misplaced Tiles heuristic
        astar_misplaced_result = astar_solve(board, misplaced_tiles)
        if astar_misplaced_result:
            solution_steps, depth, max_states = astar_misplaced_result
            astar_misplaced_depths.append(depth)
            astar_misplaced_max_states_stored.append(max_states)
            print("A* (Misplaced Tiles) Solution found.")
            print("Solution steps:", solution_steps)
            print("Solution length:", depth)
            print("Maximum states stored in A* (Misplaced Tiles):", max_states)
        else:
            print("No A* (Misplaced Tiles) solution found.")
        gc.collect()

        # A* Solve with Manhattan Distance heuristic
        astar_manhattan_result = astar_solve(board, manhattan_distance)
        if astar_manhattan_result:
            solution_steps, depth, max_states = astar_manhattan_result
            astar_manhattan_depths.append(depth)
            astar_manhattan_max_states_stored.append(max_states)
            print("A* (Manhattan Distance) Solution found.")
            print("Solution steps:", solution_steps)
            print("Solution length:", depth)
            print("Maximum states stored in A* (Manhattan Distance):", max_states)
        else:
            print("No A* (Manhattan Distance) solution found.")
        gc.collect()

        # A* Solve with Euclidean Distance heuristic
        astar_euclidean_result = astar_solve(board, euclidean_distance)
        if astar_euclidean_result:
            solution_steps, depth, max_states = astar_euclidean_result
            astar_euclidean_depths.append(depth)
            astar_euclidean_max_states_stored.append(max_states)
            print("A* (Euclidean Distance) Solution found.")
            print("Solution steps:", solution_steps)
            print("Solution length:", depth)
            print("Maximum states stored in A* (Euclidean Distance):", max_states)
        else:
            print("No A* (Euclidean Distance) solution found.")
        gc.collect()

    # A* Misplaced Tiles Statistical Analysis
    print(f"\nA* (Misplaced Tiles) Statistical Analysis for board size {size}x{size}:")
    if astar_misplaced_depths:
        print("Solution Depth: Min:", np.min(astar_misplaced_depths), "Max:", np.max(astar_misplaced_depths), "Average:", np.mean(astar_misplaced_depths))
        print("Max States Stored: Min:", np.min(astar_misplaced_max_states_stored), "Max:", np.max(astar_misplaced_max_states_stored), "Average:", np.mean(astar_misplaced_max_states_stored))
    else:
        print("No A* (Misplaced Tiles) solutions found.")

    # A* Manhattan Distance Statistical Analysis
    print(f"\nA* (Manhattan Distance) Statistical Analysis for board size {size}x{size}:")
    if astar_manhattan_depths:
        print("Solution Depth: Min:", np.min(astar_manhattan_depths), "Max:", np.max(astar_manhattan_depths), "Average:", np.mean(astar_manhattan_depths))
        print("Max States Stored: Min:", np.min(astar_manhattan_max_states_stored), "Max:", np.max(astar_manhattan_max_states_stored), "Average:", np.mean(astar_manhattan_max_states_stored))
    else:
        print("No A* (Manhattan Distance) solutions found.")

    # A* Euclidean Distance Statistical Analysis
    print(f"\nA* (Euclidean Distance) Statistical Analysis for board size {size}x{size}:")
    if astar_euclidean_depths:
        print("Solution Depth: Min:", np.min(astar_euclidean_depths), "Max:", np.max(astar_euclidean_depths), "Average:", np.mean(astar_euclidean_depths))
        print("Max States Stored: Min:", np.min(astar_euclidean_max_states_stored), "Max:", np.max(astar_euclidean_max_states_stored), "Average:", np.mean(astar_euclidean_max_states_stored))
    else:
        print("No A* (Euclidean Distance) solutions found.")

def main():
    for N in range(3, 7):  # Run for N from 3 to 6
        print(f"\nRunning simulations for board size {N}x{N}")
        simulate_board_solutions(N, trials=10)  # Run 10 trials for each size

if __name__ == "__main__":
    main()

